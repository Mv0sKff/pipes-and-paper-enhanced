<!DOCTYPE html>
<html>

<head>
  <title>Remarkable Canvas</title>
  <canvas width="1176" height="750" id="canvas-overlay"
    style="border: 1px solid #aaa; position: absolute; left: 10; right: 10"></canvas>
  <canvas width="1176" height="750" id="canvas"
    style="border: 1px solid #aaa; position: absolute; left: 10; right: 10 "></canvas>
  <style>
    .menu-icon {
      width: 30px;
      height: 30px;
    }

  </style>
</head>

<body>
  <object id="pen" class="menu-icon" type="image/svg+xml" data="static/img/pen-solid.svg"></object>
  <script src="static/js/menu.js" type="text/javascript"></script>
  <script>

    // Thanks https://github.com/ichaozi/RemarkableFramebuffer
    var MAX_X = 11277;
    var MAX_Y = 7509;
    var RATIO = MAX_X / MAX_Y;
    var MAX_PRESSURE = 4095;
    var MAX_DISPLAY_PRESSURE = 10;
    var RINGBUFFER_SIZE = 10;

    // landscape / portrait
    var rotate = false;

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");

    var canvasOverlay = document.getElementById("canvas-overlay");
    var ctxOverlay = canvasOverlay.getContext("2d");

    // Stroke only for drawing, fill only for debug.
    ctx.lineWidth = 2;

    // let websocket = new WebSocket("ws://" + location.host + "/websocket");
    let websocket = new WebSocket("ws://" + "localhost:6789" + "/websocket");

    let scaleX = canvas.width / MAX_X / 2;
    let scaleY = canvas.height / MAX_Y / 2;
    let scalePressure = MAX_DISPLAY_PRESSURE / MAX_PRESSURE;

    let penState = false;

    // Ring buffer to smooth out values.
    let ringbufferX = new Float64Array(RINGBUFFER_SIZE);
    let ringbufferY = new Float64Array(RINGBUFFER_SIZE);
    let ringbufferZ = new Float64Array(RINGBUFFER_SIZE);

    let rbI = 0;

    let debug = false;

    let lastX = null;
    let lastY = null;

    let penColor = "rgb(0, 0, 0)";

    function draw() {
      // Loop through ringbuffer elements...
      // Average all ringbuffer elements where the pressure is nonzeroish.
      let avgX = 0;
      let avgY = 0;
      let cnt = 0;
      for (i = 0; i < RINGBUFFER_SIZE; i++) {
        // If this does look like the end of a stroke, still use the whole
        // framebuffer. It's short enough to drain quickly without confusing
        // this stroke with the next.
        if (ringbufferZ[i] > 10) {
          avgX += ringbufferX[i];
          avgY += ringbufferY[i];
          cnt += 1;
        }
      }

      avgX /= cnt;
      avgY /= cnt;
      avgX *= scaleX;
      avgY *= scaleY;

      // If there were zero entries with nonzero pressure, that's the
      // end of a stroke. Forget the last point.
      if (cnt == 0) {
        penState = false;
        lastX = null;
        lastY = null;
      } else {
        // Only start drawing if we already started a line.
        if (penState) {
          if (!penColor.length) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(avgX, avgY, 10, 0, 2 * Math.PI);
            ctx.clip();
            ctx.clearRect(avgX - 11, avgY - 11, 22, 22);
            ctx.restore();
          } else {
            ctx.strokeStyle = penColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(avgX, avgY);
            ctx.stroke();
          }
        }
        penState = true;

        // Always assign last x and y when there's pen pressure,
        // to mark the start of a line.
        lastX = avgX;
        lastY = avgY;
      }
    }


    function overlay(x, y) {
      // Clear when hovering, but keep drawing for the duration of a stroke to highlight it.
      if (!penState) {
        ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
      }
      ctxOverlay.fillStyle = "rgb(200, 200, 255)";
      ctxOverlay.beginPath();
      ctxOverlay.arc(x, y, 10, 0, 2 * Math.PI);
      ctxOverlay.fill();
    }
    websocket.onmessage = function (event) {
      // data is [x, y, pressure]
      let data = JSON.parse(event.data);

      // Pre-increment rbI so we can use it in draw to refer to the current head.
      rbI = (rbI + 1) % RINGBUFFER_SIZE;
      ringbufferX[rbI] = data[0];
      ringbufferY[rbI] = data[1];
      ringbufferZ[rbI] = data[2];

      overlay(data[0] * scaleX, data[1] * scaleY);

      draw();

      if (debug) {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.fillRect(data[0] * scaleX, data[1] * scaleY, 2, 2);
        ctx.fill();
      }

    };

  </script>
</body>

</html>
